// Lua Extractor Tests
//
// Direct port of Miller's Lua extractor tests (TDD RED phase)
// Original: /Users/murphy/Source/miller/src/__tests__/parser/lua-extractor.test.ts

use crate::extractors::base::{Symbol, SymbolKind, Visibility};
use crate::extractors::lua::LuaExtractor;
use tree_sitter::Parser;

/// Initialize Lua parser for Lua files
fn init_parser() -> Parser {
    let mut parser = Parser::new();
    parser.set_language(&tree_sitter_lua::LANGUAGE.into()).expect("Error loading Lua grammar");
    parser
}

#[cfg(test)]
mod lua_extractor_tests {
    use super::*;

    #[test]
    fn test_basic_functions_and_variables() {
        let code = r#"
-- Global function
function calculateArea(width, height)
  return width * height
end

-- Local function
local function validateInput(value)
  if type(value) ~= "number" then
    error("Expected number, got " .. type(value))
  end
  return true
end

-- Anonymous function assigned to variable
local multiply = function(a, b)
  return a * b
end

-- Arrow-like function using short syntax
local add = function(x, y) return x + y end

-- Global variables
PI = 3.14159
VERSION = "1.0.0"

-- Local variables
local userName = "John Doe"
local userAge = 30
local isActive = true
local items = {}

-- Multiple assignment
local x, y, z = 10, 20, 30
local first, second = "hello", "world"

-- Function with multiple return values
function getCoordinates()
  return 100, 200
end

-- Function with varargs
function sum(...)
  local args = {...}
  local total = 0
  for i = 1, #args do
    total = total + args[i]
  end
  return total
end

-- Function with default parameter simulation
function greet(name)
  name = name or "World"
  return "Hello, " .. name .. "!"
end
"#;

        let mut parser = init_parser();
        let tree = parser.parse(code, None).unwrap();

        let mut extractor = LuaExtractor::new(
            "lua".to_string(),
            "test.lua".to_string(),
            code.to_string(),
        );

        let symbols = extractor.extract_symbols(&tree);

        // Global function
        let calculate_area = symbols.iter().find(|s| s.name == "calculateArea");
        assert!(calculate_area.is_some());
        assert_eq!(calculate_area.unwrap().kind, SymbolKind::Function);
        assert!(calculate_area.unwrap().signature.as_ref().unwrap().contains("function calculateArea(width, height)"));
        assert_eq!(calculate_area.unwrap().visibility, Some(Visibility::Public));

        // Local function
        let validate_input = symbols.iter().find(|s| s.name == "validateInput");
        assert!(validate_input.is_some());
        assert_eq!(validate_input.unwrap().kind, SymbolKind::Function);
        assert!(validate_input.unwrap().signature.as_ref().unwrap().contains("local function validateInput(value)"));
        assert_eq!(validate_input.unwrap().visibility, Some(Visibility::Private));

        // Anonymous function
        let multiply = symbols.iter().find(|s| s.name == "multiply");
        assert!(multiply.is_some());
        assert_eq!(multiply.unwrap().kind, SymbolKind::Function);
        assert!(multiply.unwrap().signature.as_ref().unwrap().contains("local multiply = function(a, b)"));

        // Short function
        let add = symbols.iter().find(|s| s.name == "add");
        assert!(add.is_some());
        assert!(add.unwrap().signature.as_ref().unwrap().contains("local add = function(x, y)"));

        // Global variables
        let pi = symbols.iter().find(|s| s.name == "PI");
        assert!(pi.is_some());
        assert_eq!(pi.unwrap().kind, SymbolKind::Variable);
        assert_eq!(pi.unwrap().visibility, Some(Visibility::Public));

        let version = symbols.iter().find(|s| s.name == "VERSION");
        assert!(version.is_some());
        assert!(version.unwrap().signature.as_ref().unwrap().contains("VERSION = \"1.0.0\""));

        // Local variables
        let user_name = symbols.iter().find(|s| s.name == "userName");
        assert!(user_name.is_some());
        assert_eq!(user_name.unwrap().kind, SymbolKind::Variable);
        assert_eq!(user_name.unwrap().visibility, "private");
        assert!(user_name.unwrap().signature.as_ref().unwrap().contains("local userName = \"John Doe\""));

        let is_active = symbols.iter().find(|s| s.name == "isActive");
        assert!(is_active.is_some());
        assert!(is_active.unwrap().signature.as_ref().unwrap().contains("local isActive = true"));

        // Multiple assignment variables
        let x = symbols.iter().find(|s| s.name == "x");
        assert!(x.is_some());
        assert!(x.unwrap().signature.as_ref().unwrap().contains("local x, y, z = 10, 20, 30"));

        // Functions with special features
        let get_coordinates = symbols.iter().find(|s| s.name == "getCoordinates");
        assert!(get_coordinates.is_some());
        assert!(get_coordinates.unwrap().signature.as_ref().unwrap().contains("function getCoordinates()"));

        let sum_fn = symbols.iter().find(|s| s.name == "sum");
        assert!(sum_fn.is_some());
        assert!(sum_fn.unwrap().signature.as_ref().unwrap().contains("function sum(...)"));

        let greet = symbols.iter().find(|s| s.name == "greet");
        assert!(greet.is_some());
        assert!(greet.unwrap().signature.as_ref().unwrap().contains("function greet(name)"));
    }

    #[test]
    fn test_tables_and_data_structures() {
        let code = r#"
-- Simple table
local config = {
  host = "localhost",
  port = 3000,
  debug = true
}

-- Table with numeric indices
local colors = {"red", "green", "blue"}

-- Mixed table
local mixed = {
  [1] = "first",
  [2] = "second",
  name = "mixed table",
  count = 42
}

-- Table with functions (methods)
local calculator = {
  value = 0,

  add = function(self, num)
    self.value = self.value + num
    return self
  end,

  subtract = function(self, num)
    self.value = self.value - num
    return self
  end,

  getValue = function(self)
    return self.value
  end
}

-- Table with colon syntax method definition
function calculator:multiply(num)
  self.value = self.value * num
  return self
end

function calculator:divide(num)
  if num ~= 0 then
    self.value = self.value / num
  end
  return self
end

-- Nested tables
local database = {
  users = {
    {id = 1, name = "Alice", active = true},
    {id = 2, name = "Bob", active = false}
  },

  settings = {
    theme = "dark",
    language = "en",
    notifications = {
      email = true,
      push = false,
      sms = true
    }
  },

  methods = {
    findUser = function(id)
      for _, user in ipairs(database.users) do
        if user.id == id then
          return user
        end
      end
      return nil
    end,

    addUser = function(user)
      table.insert(database.users, user)
    end
  }
}

-- Constructor pattern
function Person(name, age)
  local self = {
    name = name,
    age = age
  }

  function self:getName()
    return self.name
  end

  function self:getAge()
    return self.age
  end

  function self:setAge(newAge)
    if newAge >= 0 then
      self.age = newAge
    end
  end

  return self
end

-- Class-like pattern with metatable
local Animal = {}
Animal.__index = Animal

function Animal:new(species, name)
  local instance = setmetatable({}, Animal)
  instance.species = species
  instance.name = name
  return instance
end

function Animal:speak()
  return self.name .. " makes a sound"
end

function Animal:getInfo()
  return "Species: " .. self.species .. ", Name: " .. self.name
end

-- Inheritance pattern
local Dog = setmetatable({}, Animal)
Dog.__index = Dog

function Dog:new(name, breed)
  local instance = Animal.new(self, "dog", name)
  setmetatable(instance, Dog)
  instance.breed = breed
  return instance
end

function Dog:speak()
  return self.name .. " barks!"
end

function Dog:getBreed()
  return self.breed
end
"#;

        let mut parser = init_parser();
        let tree = parser.parse(code, None).unwrap();

        let mut extractor = LuaExtractor::new(
            "lua".to_string(),
            "tables.lua".to_string(),
            code.to_string(),
        );

        let symbols = extractor.extract_symbols(&tree);

        // Simple table
        let config = symbols.iter().find(|s| s.name == "config");
        assert!(config.is_some());
        assert_eq!(config.unwrap().kind, SymbolKind::Variable);
        // Note: dataType will be handled by the extractor implementation

        // Array-like table
        let colors = symbols.iter().find(|s| s.name == "colors");
        assert!(colors.is_some());

        // Calculator table with methods
        let calculator = symbols.iter().find(|s| s.name == "calculator");
        assert!(calculator.is_some());
        assert_eq!(calculator.unwrap().kind, SymbolKind::Variable);

        // Table field
        let value = symbols.iter().find(|s| s.name == "value" && s.parent_id == Some(calculator.unwrap().id.clone()));
        assert!(value.is_some());
        assert_eq!(value.unwrap().kind, SymbolKind::Field);

        // Table methods
        let add_method = symbols.iter().find(|s| s.name == "add" && s.parent_id == Some(calculator.unwrap().id.clone()));
        assert!(add_method.is_some());
        assert_eq!(add_method.unwrap().kind, SymbolKind::Method);

        let subtract_method = symbols.iter().find(|s| s.name == "subtract" && s.parent_id == Some(calculator.unwrap().id.clone()));
        assert!(subtract_method.is_some());

        // Colon syntax methods
        let multiply = symbols.iter().find(|s| s.name == "multiply" && s.signature.as_ref().unwrap().contains("calculator:multiply"));
        assert!(multiply.is_some());
        assert_eq!(multiply.unwrap().kind, SymbolKind::Method);

        let divide = symbols.iter().find(|s| s.name == "divide" && s.signature.as_ref().unwrap().contains("calculator:divide"));
        assert!(divide.is_some());

        // Nested table
        let database = symbols.iter().find(|s| s.name == "database");
        assert!(database.is_some());
        assert_eq!(database.unwrap().kind, SymbolKind::Variable);

        // Nested table fields
        let users = symbols.iter().find(|s| s.name == "users" && s.parent_id == Some(database.unwrap().id.clone()));
        assert!(users.is_some());
        assert_eq!(users.unwrap().kind, SymbolKind::Field);

        let settings = symbols.iter().find(|s| s.name == "settings" && s.parent_id == Some(database.unwrap().id.clone()));
        assert!(settings.is_some());

        // Constructor function
        let person = symbols.iter().find(|s| s.name == "Person");
        assert!(person.is_some());
        assert_eq!(person.unwrap().kind, SymbolKind::Function);
        assert!(person.unwrap().signature.as_ref().unwrap().contains("function Person(name, age)"));

        // Class-like pattern
        let animal = symbols.iter().find(|s| s.name == "Animal");
        assert!(animal.is_some());
        assert_eq!(animal.unwrap().kind, SymbolKind::Class);

        // Class methods
        let animal_new = symbols.iter().find(|s| s.name == "new" && s.parent_id == Some(animal.unwrap().id.clone()));
        assert!(animal_new.is_some());
        assert_eq!(animal_new.unwrap().kind, SymbolKind::Method);

        let speak = symbols.iter().find(|s| s.name == "speak" && s.parent_id == Some(animal.unwrap().id.clone()));
        assert!(speak.is_some());

        // Inheritance
        let dog = symbols.iter().find(|s| s.name == "Dog");
        assert!(dog.is_some());
        assert_eq!(dog.unwrap().kind, SymbolKind::Class);
        // Note: baseClass will be handled by the extractor implementation

        let dog_speak = symbols.iter().find(|s| s.name == "speak" && s.parent_id == Some(dog.unwrap().id.clone()));
        assert!(dog_speak.is_some());
        assert_eq!(dog_speak.unwrap().kind, SymbolKind::Method);
    }

    #[test]
    fn test_modules_and_require_system() {
        let code = r#"
-- Require statements
local json = require("json")
local socket = require("socket")
local http = require("socket.http")
local lfs = require("lfs")

-- Relative requires
local utils = require("./utils")
local config = require("../config/settings")

-- Module definition pattern 1: using module()
module("mymodule", package.seeall)

function publicFunction()
  return "This is public"
end

local function privateFunction()
  return "This is private"
end

-- Module definition pattern 2: return table
local M = {}

function M.add(a, b)
  return a + b
end

function M.subtract(a, b)
  return a - b
end

function M.multiply(a, b)
  return a * b
end

M.PI = 3.14159
M.VERSION = "2.0.0"

local function helper()
  return "internal helper"
end

M.getInfo = function()
  return "Math module " .. M.VERSION
end

return M

-- Alternative module pattern
local math_utils = {}

math_utils.square = function(x)
  return x * x
end

math_utils.cube = function(x)
  return x * x * x
end

math_utils.factorial = function(n)
  if n <= 1 then
    return 1
  else
    return n * math_utils.factorial(n - 1)
  end
end

-- Export selected functions
return {
  square = math_utils.square,
  cube = math_utils.cube,
  factorial = math_utils.factorial,
  constants = {
    E = 2.71828,
    PI = 3.14159
  }
}

-- Package initialization
if not package.loaded["mypackage"] then
  package.loaded["mypackage"] = {}
end

local mypackage = package.loaded["mypackage"]

mypackage.init = function()
  print("Package initialized")
end

mypackage.cleanup = function()
  print("Package cleaned up")
end

-- Conditional loading
local success, lib = pcall(require, "optional_library")
if success then
  -- Use the library
  lib.configure({debug = true})
else
  print("Optional library not available")
end

-- Dynamic require
local function loadModule(name)
  local success, module = pcall(require, name)
  if success then
    return module
  else
    error("Failed to load module: " .. name)
  end
end

-- Module caching pattern
local cache = {}

local function getCachedModule(name)
  if not cache[name] then
    cache[name] = require(name)
  end
  return cache[name]
end
"#;

        let mut parser = init_parser();
        let tree = parser.parse(code, None).unwrap();

        let mut extractor = LuaExtractor::new(
            "lua".to_string(),
            "modules.lua".to_string(),
            code.to_string(),
        );

        let symbols = extractor.extract_symbols(&tree);

        // Require statements
        let json_require = symbols.iter().find(|s| s.name == "json" && s.signature.as_ref().unwrap().contains("require(\"json\")"));
        assert!(json_require.is_some());
        assert_eq!(json_require.unwrap().kind, SymbolKind::Import);

        let socket_require = symbols.iter().find(|s| s.name == "socket" && s.signature.as_ref().unwrap().contains("require(\"socket\")"));
        assert!(socket_require.is_some());

        let http_require = symbols.iter().find(|s| s.name == "http" && s.signature.as_ref().unwrap().contains("require(\"socket.http\")"));
        assert!(http_require.is_some());

        // Relative requires
        let utils_require = symbols.iter().find(|s| s.name == "utils" && s.signature.as_ref().unwrap().contains("require(\"./utils\")"));
        assert!(utils_require.is_some());

        let config_require = symbols.iter().find(|s| s.name == "config" && s.signature.as_ref().unwrap().contains("require(\"../config/settings\")"));
        assert!(config_require.is_some());

        // Module functions
        let public_function = symbols.iter().find(|s| s.name == "publicFunction");
        assert!(public_function.is_some());
        assert_eq!(public_function.unwrap().kind, SymbolKind::Function);
        assert_eq!(public_function.unwrap().visibility, "public");

        let private_function = symbols.iter().find(|s| s.name == "privateFunction");
        assert!(private_function.is_some());
        assert_eq!(private_function.unwrap().visibility, "private");

        // Module table pattern
        let m = symbols.iter().find(|s| s.name == "M");
        assert!(m.is_some());
        assert_eq!(m.unwrap().kind, SymbolKind::Variable);

        // Module methods
        let add_method = symbols.iter().find(|s| s.name == "add" && s.parent_id == Some(m.unwrap().id.clone()));
        assert!(add_method.is_some());
        assert_eq!(add_method.unwrap().kind, SymbolKind::Method);

        let subtract_method = symbols.iter().find(|s| s.name == "subtract" && s.parent_id == Some(m.unwrap().id.clone()));
        assert!(subtract_method.is_some());

        // Module constants
        let module_pi = symbols.iter().find(|s| s.name == "PI" && s.parent_id == Some(m.unwrap().id.clone()));
        assert!(module_pi.is_some());
        assert_eq!(module_pi.unwrap().kind, SymbolKind::Field);

        // Alternative module pattern
        let math_utils = symbols.iter().find(|s| s.name == "math_utils");
        assert!(math_utils.is_some());

        let square = symbols.iter().find(|s| s.name == "square" && s.parent_id == Some(math_utils.unwrap().id.clone()));
        assert!(square.is_some());
        assert_eq!(square.unwrap().kind, SymbolKind::Method);

        // Package functions
        let load_module = symbols.iter().find(|s| s.name == "loadModule");
        assert!(load_module.is_some());
        assert!(load_module.unwrap().signature.as_ref().unwrap().contains("local function loadModule(name)"));

        let get_cached_module = symbols.iter().find(|s| s.name == "getCachedModule");
        assert!(get_cached_module.is_some());
        assert!(get_cached_module.unwrap().signature.as_ref().unwrap().contains("local function getCachedModule(name)"));
    }

    #[test]
    fn test_control_structures_and_loops() {
        let code = r#"
-- If statements with local variables
function checkAge(age)
  if age < 0 then
    local errorMsg = "Invalid age"
    error(errorMsg)
  elseif age < 18 then
    local status = "minor"
    return status
  elseif age < 65 then
    local status = "adult"
    return status
  else
    local status = "senior"
    return status
  end
end

-- Nested if statements
function processGrade(score)
  if score >= 0 and score <= 100 then
    if score >= 90 then
      local grade = "A"
      local comment = "Excellent"
      return grade, comment
    elseif score >= 80 then
      local grade = "B"
      return grade
    else
      local grade = "C or below"
      return grade
    end
  else
    error("Invalid score")
  end
end

-- For loops with local variables
function processNumbers()
  -- Numeric for loop
  for i = 1, 10 do
    local squared = i * i
    print("Square of " .. i .. " is " .. squared)
  end

  -- For loop with step
  for j = 10, 1, -1 do
    local countdown = "T-minus " .. j
    print(countdown)
  end

  -- Generic for loop with pairs
  local data = {name = "John", age = 30, city = "NYC"}
  for key, value in pairs(data) do
    local entry = key .. ": " .. tostring(value)
    print(entry)
  end

  -- Generic for loop with ipairs
  local fruits = {"apple", "banana", "orange"}
  for index, fruit in ipairs(fruits) do
    local item = "Item " .. index .. ": " .. fruit
    print(item)
  end
end

-- While loops
function waitForCondition()
  local attempts = 0
  local maxAttempts = 10
  local success = false

  while not success and attempts < maxAttempts do
    local result = performOperation()
    attempts = attempts + 1

    if result then
      success = true
      local message = "Success after " .. attempts .. " attempts"
      print(message)
    else
      local waitTime = attempts * 100
      sleep(waitTime)
    end
  end

  return success
end

-- Repeat-until loops
function readInput()
  local input
  local isValid = false

  repeat
    local prompt = "Enter a number (1-10): "
    io.write(prompt)
    input = io.read("*n")

    if input and input >= 1 and input <= 10 then
      isValid = true
      local confirmation = "You entered: " .. input
      print(confirmation)
    else
      local errorMsg = "Invalid input, please try again"
      print(errorMsg)
    end
  until isValid

  return input
end

-- Break and continue simulation
function processItems(items)
  local processed = {}
  local skipCount = 0

  for i = 1, #items do
    local item = items[i]

    -- Skip nil or empty items
    if not item or item == "" then
      skipCount = skipCount + 1
      goto continue  -- Lua 5.2+
    end

    -- Break on special marker
    if item == "STOP" then
      local stopMsg = "Processing stopped at item " .. i
      print(stopMsg)
      break
    end

    -- Process valid item
    local processedItem = string.upper(item)
    table.insert(processed, processedItem)

    ::continue::
  end

  local summary = "Processed " .. #processed .. " items, skipped " .. skipCount
  print(summary)
  return processed
end

-- Nested loops with local scoping
function createMatrix(rows, cols)
  local matrix = {}

  for i = 1, rows do
    local row = {}

    for j = 1, cols do
      local value = i * cols + j
      row[j] = value

      -- Conditional processing within nested loop
      if value % 2 == 0 then
        local evenMarker = "even"
        row[j] = {value = value, type = evenMarker}
      else
        local oddMarker = "odd"
        row[j] = {value = value, type = oddMarker}
      end
    end

    matrix[i] = row
  end

  return matrix
end

-- Iterator functions
function fibonacci(n)
  local function iter(a, b, i)
    if i > n then
      return nil
    else
      local next = a + b
      return i, a, next
    end
  end

  return iter, 1, 0, 1  -- iterator function, state, initial values
end

-- Custom iterator
function range(start, stop, step)
  local step = step or 1

  return function()
    if start <= stop then
      local current = start
      start = start + step
      return current
    end
  end
end
"#;

        let mut parser = init_parser();
        let tree = parser.parse(code, None).unwrap();

        let mut extractor = LuaExtractor::new(
            "lua".to_string(),
            "control.lua".to_string(),
            code.to_string(),
        );

        let symbols = extractor.extract_symbols(&tree);

        // Main functions
        let check_age = symbols.iter().find(|s| s.name == "checkAge");
        assert!(check_age.is_some());
        assert_eq!(check_age.unwrap().kind, SymbolKind::Function);

        let process_grade = symbols.iter().find(|s| s.name == "processGrade");
        assert!(process_grade.is_some());

        let process_numbers = symbols.iter().find(|s| s.name == "processNumbers");
        assert!(process_numbers.is_some());

        // Local variables in control structures should be detected
        let error_msg = symbols.iter().find(|s| s.name == "errorMsg" && s.visibility == "private");
        assert!(error_msg.is_some());
        assert_eq!(error_msg.unwrap().kind, SymbolKind::Variable);

        let status = symbols.iter().find(|s| s.name == "status" && s.visibility == "private");
        assert!(status.is_some());

        // Loop-related functions
        let wait_for_condition = symbols.iter().find(|s| s.name == "waitForCondition");
        assert!(wait_for_condition.is_some());

        let read_input = symbols.iter().find(|s| s.name == "readInput");
        assert!(read_input.is_some());

        let process_items = symbols.iter().find(|s| s.name == "processItems");
        assert!(process_items.is_some());

        let create_matrix = symbols.iter().find(|s| s.name == "createMatrix");
        assert!(create_matrix.is_some());

        // Iterator functions
        let fibonacci = symbols.iter().find(|s| s.name == "fibonacci");
        assert!(fibonacci.is_some());

        let range = symbols.iter().find(|s| s.name == "range");
        assert!(range.is_some());

        // Nested function in iterator
        let iter = symbols.iter().find(|s| s.name == "iter" && s.parent_id == Some(fibonacci.unwrap().id.clone()));
        assert!(iter.is_some());
        assert_eq!(iter.unwrap().kind, SymbolKind::Function);
        assert_eq!(iter.unwrap().visibility, "private");
    }

    #[test]
    fn test_coroutines_and_async_patterns() {
        let code = r#"
-- Basic coroutine
local function worker()
  local count = 0

  while true do
    local input = coroutine.yield("Working... " .. count)
    count = count + 1

    if input == "stop" then
      break
    end
  end

  return "Worker finished"
end

-- Create coroutine
local workerCo = coroutine.create(worker)

-- Producer-consumer pattern
local function producer()
  local data = {"item1", "item2", "item3", "item4"}

  for i = 1, #data do
    local item = data[i]
    coroutine.yield(item)
  end

  return "Producer done"
end

local function consumer()
  local producerCo = coroutine.create(producer)
  local results = {}

  while coroutine.status(producerCo) ~= "dead" do
    local success, value = coroutine.resume(producerCo)

    if success and value then
      local processed = "Processed: " .. value
      table.insert(results, processed)
      print(processed)
    end
  end

  return results
end

-- Async-like pattern with callbacks
local function asyncOperation(data, callback)
  -- Simulate async work
  local timer = {
    delay = 1000,
    callback = callback,
    data = data
  }

  local function complete()
    local result = "Completed: " .. timer.data
    timer.callback(nil, result)  -- error, result
  end

  -- Simulate timer (in real code this would be actual async)
  complete()
end

-- Promise-like pattern
local Promise = {}
Promise.__index = Promise

function Promise:new(executor)
  local instance = setmetatable({}, Promise)
  instance.state = "pending"
  instance.value = nil
  instance.handlers = {}

  local function resolve(value)
    if instance.state == "pending" then
      instance.state = "fulfilled"
      instance.value = value
      instance:_runHandlers()
    end
  end

  local function reject(reason)
    if instance.state == "pending" then
      instance.state = "rejected"
      instance.value = reason
      instance:_runHandlers()
    end
  end

  executor(resolve, reject)
  return instance
end

function Promise:then(onFulfilled, onRejected)
  local newPromise = Promise:new(function(resolve, reject)
    local handler = {
      onFulfilled = onFulfilled,
      onRejected = onRejected,
      resolve = resolve,
      reject = reject
    }

    if self.state == "pending" then
      table.insert(self.handlers, handler)
    else
      self:_handleHandler(handler)
    end
  end)

  return newPromise
end

function Promise:_runHandlers()
  for _, handler in ipairs(self.handlers) do
    self:_handleHandler(handler)
  end
  self.handlers = {}
end

function Promise:_handleHandler(handler)
  if self.state == "fulfilled" then
    if handler.onFulfilled then
      local success, result = pcall(handler.onFulfilled, self.value)
      if success then
        handler.resolve(result)
      else
        handler.reject(result)
      end
    else
      handler.resolve(self.value)
    end
  elseif self.state == "rejected" then
    if handler.onRejected then
      local success, result = pcall(handler.onRejected, self.value)
      if success then
        handler.resolve(result)
      else
        handler.reject(result)
      end
    else
      handler.reject(self.value)
    end
  end
end

-- Async/await simulation
local function async(fn)
  return function(...)
    local args = {...}
    return coroutine.create(function()
      return fn(table.unpack(args))
    end)
  end
end

local function await(promise)
  if type(promise) == "thread" then
    local success, result = coroutine.resume(promise)
    return result
  elseif type(promise) == "table" and promise.then then
    local co = coroutine.running()

    promise:then(function(value)
      coroutine.resume(co, value)
    end, function(error)
      coroutine.resume(co, nil, error)
    end)

    return coroutine.yield()
  end
end

-- Example async function
local fetchData = async(function(url)
  local data = await(Promise:new(function(resolve, reject)
    -- Simulate HTTP request
    local response = {
      status = 200,
      body = "Response from " .. url
    }
    resolve(response)
  end))

  return data
end)

-- Generator-like coroutine
local function range(start, stop)
  return coroutine.create(function()
    for i = start, stop do
      coroutine.yield(i)
    end
  end)
end

local function map(iter, fn)
  return coroutine.create(function()
    while coroutine.status(iter) ~= "dead" do
      local success, value = coroutine.resume(iter)
      if success and value then
        coroutine.yield(fn(value))
      end
    end
  end)
end

local function filter(iter, predicate)
  return coroutine.create(function()
    while coroutine.status(iter) ~= "dead" do
      local success, value = coroutine.resume(iter)
      if success and value and predicate(value) then
        coroutine.yield(value)
      end
    end
  end)
end
"#;

        let mut parser = init_parser();
        let tree = parser.parse(code, None).unwrap();

        let mut extractor = LuaExtractor::new(
            "lua".to_string(),
            "coroutines.lua".to_string(),
            code.to_string(),
        );

        let symbols = extractor.extract_symbols(&tree);

        // Basic coroutine function
        let worker = symbols.iter().find(|s| s.name == "worker");
        assert!(worker.is_some());
        assert_eq!(worker.unwrap().kind, SymbolKind::Function);
        assert!(worker.unwrap().signature.as_ref().unwrap().contains("local function worker()"));

        // Coroutine variable
        let worker_co = symbols.iter().find(|s| s.name == "workerCo");
        assert!(worker_co.is_some());
        assert_eq!(worker_co.unwrap().kind, SymbolKind::Variable);

        // Producer-consumer functions
        let producer = symbols.iter().find(|s| s.name == "producer");
        assert!(producer.is_some());

        let consumer = symbols.iter().find(|s| s.name == "consumer");
        assert!(consumer.is_some());

        // Async pattern function
        let async_operation = symbols.iter().find(|s| s.name == "asyncOperation");
        assert!(async_operation.is_some());
        assert!(async_operation.unwrap().signature.as_ref().unwrap().contains("local function asyncOperation(data, callback)"));

        // Promise-like class
        let promise = symbols.iter().find(|s| s.name == "Promise");
        assert!(promise.is_some());
        assert_eq!(promise.unwrap().kind, SymbolKind::Class);

        // Promise methods
        let promise_new = symbols.iter().find(|s| s.name == "new" && s.parent_id == Some(promise.unwrap().id.clone()));
        assert!(promise_new.is_some());
        assert_eq!(promise_new.unwrap().kind, SymbolKind::Method);

        let promise_then = symbols.iter().find(|s| s.name == "then" && s.parent_id == Some(promise.unwrap().id.clone()));
        assert!(promise_then.is_some());

        let run_handlers = symbols.iter().find(|s| s.name == "_runHandlers" && s.parent_id == Some(promise.unwrap().id.clone()));
        assert!(run_handlers.is_some());
        assert_eq!(run_handlers.unwrap().visibility, "private");

        // Async/await helpers
        let async_fn = symbols.iter().find(|s| s.name == "async");
        assert!(async_fn.is_some());
        assert!(async_fn.unwrap().signature.as_ref().unwrap().contains("local function async(fn)"));

        let await_fn = symbols.iter().find(|s| s.name == "await");
        assert!(await_fn.is_some());

        // Example async function
        let fetch_data = symbols.iter().find(|s| s.name == "fetchData");
        assert!(fetch_data.is_some());

        // Generator-like functions
        let range_generator = symbols.iter().find(|s| s.name == "range");
        assert!(range_generator.is_some());

        let map_fn = symbols.iter().find(|s| s.name == "map");
        assert!(map_fn.is_some());

        let filter_fn = symbols.iter().find(|s| s.name == "filter");
        assert!(filter_fn.is_some());
    }

    #[test]
    fn test_metatables_and_metamethods() {
        let code = r#"
-- Basic metatable example
local Vector = {}
Vector.__index = Vector

function Vector:new(x, y)
  local instance = {x = x or 0, y = y or 0}
  setmetatable(instance, Vector)
  return instance
end

-- Arithmetic metamethods
function Vector:__add(other)
  return Vector:new(self.x + other.x, self.y + other.y)
end

function Vector:__sub(other)
  return Vector:new(self.x - other.x, self.y - other.y)
end

function Vector:__mul(scalar)
  if type(scalar) == "number" then
    return Vector:new(self.x * scalar, self.y * scalar)
  else
    error("Can only multiply vector by number")
  end
end

function Vector:__div(scalar)
  if type(scalar) == "number" and scalar ~= 0 then
    return Vector:new(self.x / scalar, self.y / scalar)
  else
    error("Can only divide vector by non-zero number")
  end
end

-- Comparison metamethods
function Vector:__eq(other)
  return self.x == other.x and self.y == other.y
end

function Vector:__lt(other)
  return self:magnitude() < other:magnitude()
end

function Vector:__le(other)
  return self:magnitude() <= other:magnitude()
end

-- String representation
function Vector:__tostring()
  return "Vector(" .. self.x .. ", " .. self.y .. ")"
end

-- Length metamethod
function Vector:__len()
  return math.sqrt(self.x * self.x + self.y * self.y)
end

-- Index metamethod for dynamic properties
function Vector:__index(key)
  if key == "magnitude" then
    return function(self)
      return math.sqrt(self.x * self.x + self.y * self.y)
    end
  elseif key == "normalized" then
    return function(self)
      local mag = self:magnitude()
      if mag > 0 then
        return Vector:new(self.x / mag, self.y / mag)
      else
        return Vector:new(0, 0)
      end
    end
  else
    return Vector[key]
  end
end

-- Newindex metamethod for property validation
function Vector:__newindex(key, value)
  if key == "x" or key == "y" then
    if type(value) == "number" then
      rawset(self, key, value)
    else
      error("Vector coordinates must be numbers")
    end
  else
    error("Cannot set property '" .. key .. "' on Vector")
  end
end

-- Call metamethod
function Vector:__call(x, y)
  self.x = x or self.x
  self.y = y or self.y
  return self
end

-- Complex number example with multiple metamethods
local Complex = {}
Complex.__index = Complex

function Complex:new(real, imag)
  local instance = {
    real = real or 0,
    imag = imag or 0
  }
  setmetatable(instance, Complex)
  return instance
end

function Complex:__add(other)
  if type(other) == "number" then
    return Complex:new(self.real + other, self.imag)
  else
    return Complex:new(self.real + other.real, self.imag + other.imag)
  end
end

function Complex:__sub(other)
  if type(other) == "number" then
    return Complex:new(self.real - other, self.imag)
  else
    return Complex:new(self.real - other.real, self.imag - other.imag)
  end
end

function Complex:__mul(other)
  if type(other) == "number" then
    return Complex:new(self.real * other, self.imag * other)
  else
    local real = self.real * other.real - self.imag * other.imag
    local imag = self.real * other.imag + self.imag * other.real
    return Complex:new(real, imag)
  end
end

function Complex:__div(other)
  if type(other) == "number" then
    return Complex:new(self.real / other, self.imag / other)
  else
    local denominator = other.real * other.real + other.imag * other.imag
    local real = (self.real * other.real + self.imag * other.imag) / denominator
    local imag = (self.imag * other.real - self.real * other.imag) / denominator
    return Complex:new(real, imag)
  end
end

function Complex:__pow(exponent)
  if type(exponent) == "number" then
    local magnitude = math.sqrt(self.real * self.real + self.imag * self.imag)
    local angle = math.atan2(self.imag, self.real)

    local newMagnitude = magnitude ^ exponent
    local newAngle = angle * exponent

    return Complex:new(
      newMagnitude * math.cos(newAngle),
      newMagnitude * math.sin(newAngle)
    )
  else
    error("Complex exponentiation only supports number exponents")
  end
end

function Complex:__unm()
  return Complex:new(-self.real, -self.imag)
end

function Complex:__eq(other)
  return self.real == other.real and self.imag == other.imag
end

function Complex:__tostring()
  if self.imag >= 0 then
    return self.real .. " + " .. self.imag .. "i"
  else
    return self.real .. " - " .. math.abs(self.imag) .. "i"
  end
end

-- Matrix class with metamethods
local Matrix = {}
Matrix.__index = Matrix

function Matrix:new(rows, cols, defaultValue)
  local instance = {
    rows = rows,
    cols = cols,
    data = {}
  }

  for i = 1, rows do
    instance.data[i] = {}
    for j = 1, cols do
      instance.data[i][j] = defaultValue or 0
    end
  end

  setmetatable(instance, Matrix)
  return instance
end

function Matrix:__index(key)
  if type(key) == "number" then
    return self.data[key]
  else
    return Matrix[key]
  end
end

function Matrix:__newindex(key, value)
  if type(key) == "number" then
    if type(value) == "table" and #value == self.cols then
      self.data[key] = value
    else
      error("Matrix row must be a table with " .. self.cols .. " elements")
    end
  else
    rawset(self, key, value)
  end
end

function Matrix:__add(other)
  if self.rows ~= other.rows or self.cols ~= other.cols then
    error("Matrix dimensions must match for addition")
  end

  local result = Matrix:new(self.rows, self.cols)
  for i = 1, self.rows do
    for j = 1, self.cols do
      result.data[i][j] = self.data[i][j] + other.data[i][j]
    end
  end

  return result
end

function Matrix:__mul(other)
  if type(other) == "number" then
    local result = Matrix:new(self.rows, self.cols)
    for i = 1, self.rows do
      for j = 1, self.cols do
        result.data[i][j] = self.data[i][j] * other
      end
    end
    return result
  elseif self.cols == other.rows then
    local result = Matrix:new(self.rows, other.cols)
    for i = 1, self.rows do
      for j = 1, other.cols do
        local sum = 0
        for k = 1, self.cols do
          sum = sum + self.data[i][k] * other.data[k][j]
        end
        result.data[i][j] = sum
      end
    end
    return result
  else
    error("Invalid matrix multiplication dimensions")
  end
end

function Matrix:__tostring()
  local lines = {}
  for i = 1, self.rows do
    local row = {}
    for j = 1, self.cols do
      table.insert(row, tostring(self.data[i][j]))
    end
    table.insert(lines, "[" .. table.concat(row, ", ") .. "]")
  end
  return "Matrix:\n" .. table.concat(lines, "\n")
end

-- Weak table example
local Cache = {}
Cache.__index = Cache

function Cache:new(mode)
  local instance = {
    data = {}
  }

  -- Set up weak table
  local meta = {__mode = mode or "k"}  -- weak keys by default
  setmetatable(instance.data, meta)
  setmetatable(instance, Cache)

  return instance
end

function Cache:set(key, value)
  self.data[key] = value
end

function Cache:get(key)
  return self.data[key]
end

function Cache:size()
  local count = 0
  for _ in pairs(self.data) do
    count = count + 1
  end
  return count
end
"#;

        let mut parser = init_parser();
        let tree = parser.parse(code, None).unwrap();

        let mut extractor = LuaExtractor::new(
            "lua".to_string(),
            "metatables.lua".to_string(),
            code.to_string(),
        );

        let symbols = extractor.extract_symbols(&tree);

        // Vector class
        let vector = symbols.iter().find(|s| s.name == "Vector");
        assert!(vector.is_some());
        assert_eq!(vector.unwrap().kind, SymbolKind::Class);

        // Vector constructor
        let vector_new = symbols.iter().find(|s| s.name == "new" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_new.is_some());
        assert_eq!(vector_new.unwrap().kind, SymbolKind::Method);

        // Arithmetic metamethods
        let vector_add = symbols.iter().find(|s| s.name == "__add" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_add.is_some());
        assert_eq!(vector_add.unwrap().kind, SymbolKind::Method);
        assert!(vector_add.unwrap().signature.as_ref().unwrap().contains("function Vector:__add(other)"));

        let vector_sub = symbols.iter().find(|s| s.name == "__sub" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_sub.is_some());

        let vector_mul = symbols.iter().find(|s| s.name == "__mul" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_mul.is_some());

        let vector_div = symbols.iter().find(|s| s.name == "__div" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_div.is_some());

        // Comparison metamethods
        let vector_eq = symbols.iter().find(|s| s.name == "__eq" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_eq.is_some());

        let vector_lt = symbols.iter().find(|s| s.name == "__lt" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_lt.is_some());

        // String representation
        let vector_tostring = symbols.iter().find(|s| s.name == "__tostring" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_tostring.is_some());

        // Length metamethod
        let vector_len = symbols.iter().find(|s| s.name == "__len" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_len.is_some());

        // Index metamethods
        let vector_index = symbols.iter().find(|s| s.name == "__index" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_index.is_some());

        let vector_newindex = symbols.iter().find(|s| s.name == "__newindex" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_newindex.is_some());

        // Call metamethod
        let vector_call = symbols.iter().find(|s| s.name == "__call" && s.parent_id == Some(vector.unwrap().id.clone()));
        assert!(vector_call.is_some());

        // Complex number class
        let complex = symbols.iter().find(|s| s.name == "Complex");
        assert!(complex.is_some());
        assert_eq!(complex.unwrap().kind, SymbolKind::Class);

        // Complex metamethods
        let complex_add = symbols.iter().find(|s| s.name == "__add" && s.parent_id == Some(complex.unwrap().id.clone()));
        assert!(complex_add.is_some());

        let complex_pow = symbols.iter().find(|s| s.name == "__pow" && s.parent_id == Some(complex.unwrap().id.clone()));
        assert!(complex_pow.is_some());

        let complex_unm = symbols.iter().find(|s| s.name == "__unm" && s.parent_id == Some(complex.unwrap().id.clone()));
        assert!(complex_unm.is_some());

        // Matrix class
        let matrix = symbols.iter().find(|s| s.name == "Matrix");
        assert!(matrix.is_some());
        assert_eq!(matrix.unwrap().kind, SymbolKind::Class);

        // Matrix methods and metamethods
        let matrix_new = symbols.iter().find(|s| s.name == "new" && s.parent_id == Some(matrix.unwrap().id.clone()));
        assert!(matrix_new.is_some());

        let matrix_add = symbols.iter().find(|s| s.name == "__add" && s.parent_id == Some(matrix.unwrap().id.clone()));
        assert!(matrix_add.is_some());

        let matrix_mul = symbols.iter().find(|s| s.name == "__mul" && s.parent_id == Some(matrix.unwrap().id.clone()));
        assert!(matrix_mul.is_some());

        // Cache class with weak tables
        let cache = symbols.iter().find(|s| s.name == "Cache");
        assert!(cache.is_some());
        assert_eq!(cache.unwrap().kind, SymbolKind::Class);

        let cache_set = symbols.iter().find(|s| s.name == "set" && s.parent_id == Some(cache.unwrap().id.clone()));
        assert!(cache_set.is_some());

        let cache_get = symbols.iter().find(|s| s.name == "get" && s.parent_id == Some(cache.unwrap().id.clone()));
        assert!(cache_get.is_some());
    }

    #[test]
    fn test_string_patterns_and_regex() {
        let code = r#"
-- Basic string patterns
local function validateEmail(email)
  local pattern = "^[%w._-]+@[%w.-]+%.%w+$"
  return string.match(email, pattern) ~= nil
end

local function extractNumbers(text)
  local numbers = {}
  for number in string.gmatch(text, "%d+") do
    table.insert(numbers, tonumber(number))
  end
  return numbers
end

-- Advanced pattern matching
local function parseLogLine(line)
  local pattern = "(%d+%-%d+%-%d+) (%d+:%d+:%d+) %[(%w+)%] (.+)"
  local date, time, level, message = string.match(line, pattern)

  if date then
    return {
      date = date,
      time = time,
      level = level,
      message = message
    }
  else
    return nil
  end
end

local function extractUrls(text)
  local urls = {}
  local pattern = "https?://[%w%-._~:/?#%[%]@!$&'()*+,;=]+"

  for url in string.gmatch(text, pattern) do
    table.insert(urls, url)
  end

  return urls
end

-- String replacement and cleaning
local function cleanHtml(html)
  -- Remove HTML tags
  local cleaned = string.gsub(html, "<[^>]*>", "")

  -- Replace HTML entities
  local entities = {
    ["&lt;"] = "<",
    ["&gt;"] = ">",
    ["&amp;"] = "&",
    ["&quot;"] = '"',
    ["&apos;"] = "'",
    ["&#39;"] = "'"
  }

  for entity, replacement in pairs(entities) do
    cleaned = string.gsub(cleaned, entity, replacement)
  end

  -- Remove extra whitespace
  cleaned = string.gsub(cleaned, "%s+", " ")
  cleaned = string.gsub(cleaned, "^%s+", "")
  cleaned = string.gsub(cleaned, "%s+$", "")

  return cleaned
end

local function formatPhoneNumber(phone)
  -- Remove all non-digits
  local digits = string.gsub(phone, "%D", "")

  -- Format US phone numbers
  if #digits == 10 then
    local area = string.sub(digits, 1, 3)
    local exchange = string.sub(digits, 4, 6)
    local number = string.sub(digits, 7, 10)
    return "(" .. area .. ") " .. exchange .. "-" .. number
  elseif #digits == 11 and string.sub(digits, 1, 1) == "1" then
    local area = string.sub(digits, 2, 4)
    local exchange = string.sub(digits, 5, 7)
    local number = string.sub(digits, 8, 11)
    return "+1 (" .. area .. ") " .. exchange .. "-" .. number
  else
    return digits  -- Return cleaned digits if format unknown
  end
end

-- Template processing
local function processTemplate(template, variables)
  local result = template

  -- Replace {{variable}} patterns
  result = string.gsub(result, "{{(%w+)}}", function(varName)
    return tostring(variables[varName] or "")
  end)

  -- Replace {variable} patterns
  result = string.gsub(result, "{(%w+)}", function(varName)
    return tostring(variables[varName] or "")
  end)

  return result
end

local function parseQueryString(queryString)
  local params = {}

  -- Split by & and parse key=value pairs
  for pair in string.gmatch(queryString, "[^&]+") do
    local key, value = string.match(pair, "([^=]+)=([^=]*)")
    if key and value then
      -- URL decode
      key = string.gsub(key, "+", " ")
      key = string.gsub(key, "%%(%x%x)", function(hex)
        return string.char(tonumber(hex, 16))
      end)

      value = string.gsub(value, "+", " ")
      value = string.gsub(value, "%%(%x%x)", function(hex)
        return string.char(tonumber(hex, 16))
      end)

      params[key] = value
    end
  end

  return params
end

-- CSV parsing with patterns
local function parseCSV(csvText)
  local rows = {}
  local currentRow = {}
  local currentField = ""
  local inQuotes = false

  for i = 1, #csvText do
    local char = string.sub(csvText, i, i)

    if char == '"' then
      if inQuotes and i < #csvText and string.sub(csvText, i + 1, i + 1) == '"' then
        -- Escaped quote
        currentField = currentField .. '"'
        i = i + 1  -- Skip next quote
      else
        inQuotes = not inQuotes
      end
    elseif char == ',' and not inQuotes then
      table.insert(currentRow, currentField)
      currentField = ""
    elseif char == '\n' and not inQuotes then
      table.insert(currentRow, currentField)
      table.insert(rows, currentRow)
      currentRow = {}
      currentField = ""
    else
      currentField = currentField .. char
    end
  end

  -- Add last field and row if not empty
  if currentField ~= "" or #currentRow > 0 then
    table.insert(currentRow, currentField)
    table.insert(rows, currentRow)
  end

  return rows
end

-- Pattern-based validation
local Validator = {}
Validator.__index = Validator

function Validator:new()
  local instance = {
    patterns = {
      email = "^[%w._-]+@[%w.-]+%.%w+$",
      phone = "^%+?[%d%s%-()]+$",
      url = "^https?://[%w%-._~:/?#%[%]@!$&'()*+,;=]+$",
      creditCard = "^%d%d%d%d[%s%-]?%d%d%d%d[%s%-]?%d%d%d%d[%s%-]?%d%d%d%d$",
      zipCode = "^%d%d%d%d%d(%-?%d%d%d%d)?$",
      ipAddress = "^%d+%.%d+%.%d+%.%d+$"
    }
  }

  setmetatable(instance, Validator)
  return instance
end

function Validator:validate(value, type)
  local pattern = self.patterns[type]
  if not pattern then
    error("Unknown validation type: " .. type)
  end

  return string.match(value, pattern) ~= nil
end

function Validator:addPattern(name, pattern)
  self.patterns[name] = pattern
end

function Validator:getPattern(name)
  return self.patterns[name]
end

-- Text processing utilities
local TextUtils = {}

function TextUtils.splitLines(text)
  local lines = {}
  for line in string.gmatch(text, "[^\r\n]+") do
    table.insert(lines, line)
  end
  return lines
end

function TextUtils.splitWords(text)
  local words = {}
  for word in string.gmatch(text, "%S+") do
    table.insert(words, word)
  end
  return words
end

function TextUtils.capitalize(text)
  return string.gsub(text, "(%l)(%w*)", function(first, rest)
    return string.upper(first) .. rest
  end)
end

function TextUtils.camelCase(text)
  local result = string.gsub(text, "[-_](%l)", function(letter)
    return string.upper(letter)
  end)
  return string.gsub(result, "^%u", string.lower)
end

function TextUtils.snakeCase(text)
  local result = string.gsub(text, "(%u)", function(letter)
    return "_" .. string.lower(letter)
  end)
  return string.gsub(result, "^_", "")
end

function TextUtils.truncate(text, maxLength, suffix)
  suffix = suffix or "..."
  if #text <= maxLength then
    return text
  else
    return string.sub(text, 1, maxLength - #suffix) .. suffix
  end
end

-- Regular expression-like functionality
local function escapePattern(text)
  -- Escape Lua pattern special characters
  return string.gsub(text, "([%^%$%(%)%%%.%[%]%*%+%-%?])", "%%%1")
end

local function replaceAll(text, search, replacement)
  local escapedSearch = escapePattern(search)
  return string.gsub(text, escapedSearch, replacement)
end

local function contains(text, substring, ignoreCase)
  if ignoreCase then
    text = string.lower(text)
    substring = string.lower(substring)
  end

  return string.find(text, escapePattern(substring), 1, true) ~= nil
end
"#;

        let mut parser = init_parser();
        let tree = parser.parse(code, None).unwrap();

        let mut extractor = LuaExtractor::new(
            "lua".to_string(),
            "strings.lua".to_string(),
            code.to_string(),
        );

        let symbols = extractor.extract_symbols(&tree);

        // Basic pattern functions
        let validate_email = symbols.iter().find(|s| s.name == "validateEmail");
        assert!(validate_email.is_some());
        assert_eq!(validate_email.unwrap().kind, SymbolKind::Function);
        assert!(validate_email.unwrap().signature.as_ref().unwrap().contains("local function validateEmail(email)"));

        let extract_numbers = symbols.iter().find(|s| s.name == "extractNumbers");
        assert!(extract_numbers.is_some());

        // Advanced pattern matching
        let parse_log_line = symbols.iter().find(|s| s.name == "parseLogLine");
        assert!(parse_log_line.is_some());

        let extract_urls = symbols.iter().find(|s| s.name == "extractUrls");
        assert!(extract_urls.is_some());

        // String processing functions
        let clean_html = symbols.iter().find(|s| s.name == "cleanHtml");
        assert!(clean_html.is_some());

        let format_phone_number = symbols.iter().find(|s| s.name == "formatPhoneNumber");
        assert!(format_phone_number.is_some());

        // Template processing
        let process_template = symbols.iter().find(|s| s.name == "processTemplate");
        assert!(process_template.is_some());

        let parse_query_string = symbols.iter().find(|s| s.name == "parseQueryString");
        assert!(parse_query_string.is_some());

        // CSV parsing
        let parse_csv = symbols.iter().find(|s| s.name == "parseCSV");
        assert!(parse_csv.is_some());

        // Validator class (Note: May be affected by tree-sitter parser limitations)
        let validator = symbols.iter().find(|s| s.name == "Validator");
        // TODO: These may fail due to tree-sitter limitations mentioned in Miller tests
        if validator.is_some() {
            assert_eq!(validator.unwrap().kind, SymbolKind::Class);
        }

        // TextUtils module (Note: May be affected by tree-sitter parser limitations)
        let text_utils = symbols.iter().find(|s| s.name == "TextUtils");
        if text_utils.is_some() {
            assert_eq!(text_utils.unwrap().kind, SymbolKind::Variable);
        }

        // Utility functions
        let escape_pattern = symbols.iter().find(|s| s.name == "escapePattern");
        assert!(escape_pattern.is_some());

        let replace_all = symbols.iter().find(|s| s.name == "replaceAll");
        assert!(replace_all.is_some());

        let contains_fn = symbols.iter().find(|s| s.name == "contains");
        assert!(contains_fn.is_some());
    }
}