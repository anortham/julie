//! Inline tests extracted from src/workspace/registry.rs
//!
//! These tests verify core registry functionality:
//! - Workspace ID generation with consistent hashing
//! - Name sanitization for filesystem compatibility
//! - Expiration logic for primary vs reference workspaces

use crate::workspace::registry::*;

#[test]
fn test_generate_workspace_id() {
    let path = "/Users/test/project-a";
    let id = generate_workspace_id(path).unwrap();

    // Should be format: name_hash8
    assert!(id.contains('_'));
    let parts: Vec<&str> = id.split('_').collect();
    assert_eq!(parts.len(), 2);
    assert_eq!(parts[1].len(), 8); // Hash should be 8 chars
}

#[test]
fn test_sanitize_name() {
    assert_eq!(sanitize_name("project-a"), "project-a");
    assert_eq!(sanitize_name("Project A"), "project_a");
    assert_eq!(sanitize_name("my:project"), "my_project");
    assert_eq!(sanitize_name(""), "ws_");
}

#[test]
fn test_workspace_entry_expiration() {
    let config = RegistryConfig::default();

    // Primary workspace should never expire
    let primary =
        WorkspaceEntry::new("/test/primary".to_string(), WorkspaceType::Primary, &config).unwrap();
    assert!(!primary.is_expired());
    assert!(primary.expires_at.is_none());

    // Reference workspace should have expiration
    let reference = WorkspaceEntry::new(
        "/test/reference".to_string(),
        WorkspaceType::Reference,
        &config,
    )
    .unwrap();
    assert!(!reference.is_expired()); // Should not be expired immediately
    assert!(reference.expires_at.is_some());
}

#[test]
#[cfg(windows)]
fn test_windows_path_normalization() {
    // Test that Windows paths with different formats generate SAME workspace ID
    // This is critical for consistent workspace identification

    // Backslash path (Windows native)
    let backslash_path = r"C:\Users\Test\project";
    let id1 = generate_workspace_id(backslash_path).unwrap();

    // Forward slash path (cross-platform style)
    let forward_slash_path = "C:/Users/Test/project";
    let id2 = generate_workspace_id(forward_slash_path).unwrap();

    // These should generate THE SAME workspace ID due to normalization
    assert_eq!(
        id1, id2,
        "Windows paths with backslash vs forward slash should normalize to same ID"
    );

    // Verify format: name_hash8
    assert!(id1.contains('_'));
    let parts: Vec<&str> = id1.split('_').collect();
    assert_eq!(parts.len(), 2);
    assert_eq!(parts[1].len(), 8);
}

#[test]
#[cfg(windows)]
fn test_windows_case_normalization() {
    // Windows is case-insensitive for paths
    // Verify that C:\ and c:\ generate same workspace ID

    let uppercase_drive = r"C:\source\project";
    let lowercase_drive = r"c:\source\project";

    let id1 = generate_workspace_id(uppercase_drive).unwrap();
    let id2 = generate_workspace_id(lowercase_drive).unwrap();

    assert_eq!(
        id1, id2,
        "Windows paths should be case-normalized (C:\\ vs c:\\)"
    );
}

#[test]
#[cfg(windows)]
fn test_windows_unc_path() {
    // UNC paths (extended-length paths) start with \\?\
    // These are used by Windows for paths > 260 characters

    let unc_path = r"\\?\C:\Users\VeryLongUserName\VeryLongProjectName\project";

    let id = generate_workspace_id(unc_path).unwrap();

    // Should successfully generate workspace ID
    assert!(id.contains('_'));
    let parts: Vec<&str> = id.split('_').collect();
    assert_eq!(parts.len(), 2);
    assert_eq!(parts[1].len(), 8);

    // Workspace name should be sanitized
    assert!(id.starts_with("project_") || id.starts_with("verylong"));
}

#[test]
#[cfg(windows)]
fn test_windows_path_with_spaces() {
    // Windows paths often have spaces (e.g., "Program Files", "My Documents")

    let path_with_spaces = r"C:\Users\Test User\My Projects\project-a";

    let id = generate_workspace_id(path_with_spaces).unwrap();

    // Should successfully generate workspace ID
    assert!(id.contains('_'));

    // Spaces should be sanitized in workspace name
    let parts: Vec<&str> = id.split('_').collect();
    assert_eq!(parts.len(), 2);

    // Verify workspace name is filesystem-safe (no spaces)
    assert!(
        !parts[0].contains(' '),
        "Workspace name should not contain spaces"
    );
}

#[test]
#[cfg(windows)]
fn test_windows_short_path_names() {
    // Windows 8.3 short path format (e.g., CHS300~1 for CHS300372)
    // These are generated by Windows for long directory names

    let short_path = r"C:\Users\CHS300~1\AppData\Local\Temp\.tmpsflGsh";

    let id = generate_workspace_id(short_path).unwrap();

    // Should successfully generate workspace ID
    assert!(id.contains('_'));

    // Workspace ID format: name_hash8, but name may contain underscores from sanitization
    // Just verify the hash at the end is 8 hex characters
    let parts: Vec<&str> = id.rsplitn(2, '_').collect();
    assert_eq!(
        parts.len(),
        2,
        "Workspace ID should have format: name_hash8"
    );
    assert_eq!(parts[0].len(), 8, "Hash should be 8 characters");
    assert!(
        parts[0].chars().all(|c| c.is_ascii_hexdigit()),
        "Hash should be hex characters only"
    );

    // Workspace name should be sanitized (no ~ or . at start)
    let workspace_name = parts[1];
    assert!(
        !workspace_name.starts_with('.'),
        "Workspace name should not start with ."
    );
    assert!(
        !workspace_name.contains('~'),
        "Workspace name should not contain ~"
    );
}

#[test]
fn test_cross_platform_path_consistency() {
    // Test that path normalization is consistent across runs
    // This is critical for workspace identification persistence

    let path = if cfg!(windows) {
        r"C:\source\julie"
    } else {
        "/source/julie"
    };

    let id1 = generate_workspace_id(path).unwrap();
    let id2 = generate_workspace_id(path).unwrap();

    assert_eq!(
        id1, id2,
        "Same path should always generate same workspace ID"
    );

    // Verify hash is stable (SHA256 should be deterministic)
    let parts: Vec<&str> = id1.split('_').collect();
    assert_eq!(parts.len(), 2);
    assert_eq!(parts[1].len(), 8);

    // Hash should be hex characters only
    assert!(
        parts[1].chars().all(|c| c.is_ascii_hexdigit()),
        "Hash should contain only hex characters"
    );
}

#[test]
#[cfg(windows)]
fn test_windows_different_drives() {
    // Test that different drive letters produce different workspace IDs

    let c_drive = r"C:\project\test";
    let d_drive = r"D:\project\test";

    let id_c = generate_workspace_id(c_drive).unwrap();
    let id_d = generate_workspace_id(d_drive).unwrap();

    // Different drives should produce different IDs (different paths!)
    assert_ne!(
        id_c, id_d,
        "Same project on different drives should have different IDs"
    );
}
