---
git:
  branch: main
  commit: 060814f
  dirty: true
id: learning_698558cb_9ca960
tags:
- fast_refs
- audit
- identifiers
- relationships
- database
- gap-analysis
timestamp: 1770346699
type: learning
---

Comprehensive fast_refs audit completed

ENTRY POINT: FastRefsTool::call_tool() -> find_references_and_definitions()

FULL CODE PATH:
1. FastRefsTool::call_tool() @ fast_refs.rs:150
   - Calls find_references_and_definitions() @ line 154
   - Returns CallToolResult with formatted output

2. find_references_and_definitions() @ fast_refs.rs:189
   - Resolves workspace parameter (line 199)
   - For reference workspaces: delegates to reference_workspace module (line 205)
   - For primary workspace: searches in memory with handler.get_workspace().db

3. PRIMARY WORKSPACE SEARCH (lines 209-336):
   a) Find definitions using SQLite (lines 214-238)
      - Calls db_lock.get_symbols_by_name(&symbol) @ line 231
      - O(log n) indexed query on symbols(name)
   
   b) Find cross-language variants (lines 242-288)
      - Uses generate_naming_variants() for snake_case/camelCase variants
      - Queries each variant via db_lock.get_symbols_by_name()
      - Deduplicates results by symbol ID
   
   c) Find references to all definitions (lines 294-336)
      - Builds Vec<definition_ids> from definitions
      - Calls EITHER:
        * db_lock.get_relationships_to_symbols(&definition_ids) [NO filter]
        * db_lock.get_relationships_to_symbols_filtered_by_kind(&definition_ids, &kind) [WITH filter]
      - Both return Vec<Relationship> from relationships table
   
   d) Sort & limit (lines 338-359)
      - Sorts by confidence (desc), file_path, line_number
      - Truncates to self.limit (default 10)

4. IDENTIFIERS TABLE SCHEMA @ database/schema.rs:173-232
   - 176 columns: id, name, kind, language, file_path, start_line, start_col, end_line, end_col, start_byte, end_byte, containing_symbol_id, target_symbol_id, confidence, code_context, last_indexed
   - Indexes: idx_identifiers_name, idx_identifiers_file, idx_identifiers_containing, idx_identifiers_target, idx_identifiers_kind (line 206-228)
   - Foreign keys: containing_symbol_id → symbols.id, target_symbol_id → symbols.id

DATA FLOW GAP IDENTIFIED:
- fast_refs queries RELATIONSHIPS table (from_symbol_id, to_symbol_id)
- fast_refs does NOT query IDENTIFIERS table at all
- get_relationships_to_symbols_filtered_by_kind() JOINs identifiers ON (file_path, start_line) but filters by identifier.kind
- BUG: The JOIN in get_relationships_to_symbols_filtered_by_kind() @ relationships.rs:146 matches IDENTIFIERS but returns RELATIONSHIPS
  This means if a relationship and identifier don't occur at exact same line, they won't be linked
- IDENTIFIERS are extracted per-language in 31 extractors but never used in primary fast_refs path without reference_kind filter

IDENTIFIER POPULATION:
- ALL 31 languages have identifiers.rs extractors:
  * Stateful languages (16): rust, typescript, javascript, python, java, csharp, php, swift, kotlin, dart, go, c, cpp, powershell, bash, zig
  * Dynamic languages (5): ruby, lua, gdscript, qml, r
  * Markup/config (4): css, markdown, json, toml, yaml
  * Special (3): sql, html, razor, regex, vue
  * Total extractors: 32 (some have separate test files)

- IDENTIFIER KINDS extracted (from types.rs:130-143):
  * Call (function/method calls)
  * VariableRef (variable references)
  * TypeUsage (type annotations)
  * MemberAccess (object.property)
  * Import (import/use statements)

- EXTRACTION FLOW:
  1. factory.rs:extract_symbols_and_relationships() calls extract_identifiers(tree, &symbols) for ALL languages
  2. Each extractor walks AST and populates base_extractor.identifiers
  3. processor.rs:process_file_with_parser() @ line 640 returns identifiers
  4. processor.rs lines 150, 300 extend all_identifiers and call bulk_store_identifiers()
  5. bulk_operations.rs:bulk_store_identifiers() @ line 62 INSERT OR REPLACE into identifiers table

RELATIONSHIPS POPULATION:
- 31 languages extract relationships (factory.rs lines 62-329)
- processor.rs line 148 extends all_relationships
- processor.rs line 295 calls bulk_store_relationships()
- bulk_operations.rs:store_relationships()/bulk_store_relationships() @ lines 406/445 INSERT into relationships table
- PendingRelationships are resolved post-indexing @ processor.rs:398-457

REFERENCE_KIND FILTER HANDLING (fast_refs.rs:310-327):
- reference_kind parameter passed to get_relationships_to_symbols_filtered_by_kind()
- Query JOINs identifiers ON (file_path, start_line) 
- Filters by i.kind = ? parameter (line 148 in relationships.rs)
- Returns only relationships that match BOTH:
  * to_symbol_id IN (definition_ids)
  * Identifier exists at same file_path and start_line
  * Identifier.kind matches reference_kind

OUTPUT FIELDS:
- Definitions: name, kind, language, file_path, start_line, start_column, end_line, end_column, signature
- References: from_symbol_id, to_symbol_id, kind, file_path, line_number, confidence
- Both always populated when found, none are optional in current implementation

KEY FINDINGS:
1. Identifiers are fully populated in database but primary fast_refs path IGNORES them
2. Only filtered path (reference_kind) uses identifiers table at all
3. Relationships table is primary source of truth for ALL references
4. Cross-language naming convention matching is handled in fast_refs.rs, not in database
5. Reference_kind filtering relies on file_path+start_line JOIN (potential gap if identifiers extracted at different positions)
6. No semantic/type-based filtering despite having TypeUsage and type information available
