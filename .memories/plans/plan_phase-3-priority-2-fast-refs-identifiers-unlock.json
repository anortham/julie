{
  "id": "plan_phase-3-priority-2-fast-refs-identifiers-unlock",
  "timestamp": 1770347419,
  "type": "plan",
  "title": "Phase 3 Priority 2: fast_refs Identifiers Unlock",
  "status": "active",
  "content": "## Phase 3 Priority 2: fast_refs + Identifiers Unlock\n\n### Problem Statement\nfast_refs relies ONLY on the `relationships` table for finding references. When relationship data is sparse (which it is for many symbols), fast_refs returns 0 results. Meanwhile, the `identifiers` table has ~1.2M records populated by all 31 extractors — but has **zero query functions**. It's a write-only table.\n\n**Evidence from dogfood testing:**\n- SearchIndex: 0 refs from fast_refs, 50+ from fast_search\n- text_search_impl: 1 ref from fast_refs, 50+ from fast_search\n- reference_kind=\"call\" filtering: returns 0 even when unfiltered returns 114 (broken JOIN)\n\n### Root Cause\n1. No `get_identifiers_by_*()` query functions exist in `src/database/`\n2. No `row_to_identifier()` helper exists in `src/database/helpers.rs`\n3. fast_refs only queries relationships table, never identifiers\n4. reference_kind filtering uses fragile JOIN on (file_path, start_line) that rarely matches\n\n### Implementation Plan\n\n#### Task 1: Add database identifier query layer (~100 lines)\n**New file: `src/database/identifiers.rs`**\n\nCreate a lightweight `IdentifierRef` struct (just the fields fast_refs needs):\n```rust\npub(crate) struct IdentifierRef {\n    pub name: String,\n    pub kind: String,           // \"call\", \"variable_ref\", \"type_usage\", \"member_access\", \"import\"\n    pub file_path: String,\n    pub start_line: u32,\n    pub containing_symbol_id: Option<String>,\n    pub confidence: f32,\n}\n```\n\nQuery functions on `SymbolDatabase`:\n- `get_identifiers_by_names(names: &[String]) -> Result<Vec<IdentifierRef>>`\n  - SQL: `SELECT name, kind, file_path, start_line, containing_symbol_id, confidence FROM identifiers WHERE name IN (?...)`\n  - Uses existing `idx_identifiers_name` index\n- `get_identifiers_by_names_and_kind(names: &[String], kind: &str) -> Result<Vec<IdentifierRef>>`\n  - Same + `AND kind = ?` filter\n  - Uses `idx_identifiers_name` + `idx_identifiers_kind`\n\nRegister module in `src/database/mod.rs`.\n\n#### Task 2: Integrate identifiers into fast_refs\n**Modify: `src/tools/navigation/fast_refs.rs` — `find_references_and_definitions()`**\n\nAfter the existing relationship lookup (line ~336), add identifier-based discovery:\n\n1. Collect `all_names`: original symbol + cross-language variants (already computed)\n2. Query identifiers:\n   - If `reference_kind` is set → `get_identifiers_by_names_and_kind(&all_names, &kind)`\n   - If not set → `get_identifiers_by_names(&all_names)`\n3. Convert each `IdentifierRef` to a `Relationship`:\n   - `containing_symbol_id` → `from_symbol_id`\n   - First definition ID → `to_symbol_id`\n   - Map IdentifierKind → RelationshipKind (call→Calls, import→Imports, rest→References)\n4. Deduplicate: build `HashSet<(file_path, line_number)>` from existing relationship results; only add identifier-based refs that don't collide\n5. Merge into references vector\n\nThis converts identifiers to Relationships so the entire formatting pipeline (lean, JSON, TOON) works unchanged.\n\n#### Task 3: Fix reference_kind filtering\n**Modify: `src/tools/navigation/fast_refs.rs`**\n\nCurrent broken flow (reference_kind set):\n```\nrelationships JOIN identifiers ON (file_path, start_line) WHERE kind = ? → 0 results\n```\n\nNew flow (reference_kind set):\n```\n1. Get relationships (unfiltered) → filter by RelationshipKind match\n2. Get identifiers by name + kind → convert to Relationship\n3. Merge and dedup\n```\n\nThis replaces the fragile JOIN with direct identifier queries. The `get_relationships_to_symbols_filtered_by_kind()` function in `relationships.rs` can be deprecated/removed later.\n\n#### Task 4: Add dogfood regression tests\n**File: `src/tests/tools/navigation/fast_refs_quality.rs`** (or similar)\n\nTDD approach — write failing tests first:\n- `test_fast_refs_finds_struct_references` — SearchIndex should return > 0 references\n- `test_fast_refs_finds_function_references` — text_search_impl should return > 1 reference\n- `test_fast_refs_reference_kind_call_filter` — reference_kind=\"call\" returns > 0 results\n- `test_fast_refs_deduplicates_relationship_and_identifier_refs` — no duplicate (file, line) pairs\n\n#### Task 5: Verification\n- Run full test suite (`cargo test --lib`)\n- Live dogfood: test fast_refs for SearchIndex, text_search_impl, Symbol\n- Verify reference_kind filtering works\n- Check that well-connected symbols (JulieServerHandler) still return correct results\n\n### Key Design Decisions\n1. **Convert identifiers to Relationships** (not new types) — zero changes to formatting pipeline\n2. **Merge, don't replace** — relationships have richer data (from_symbol_id, to_symbol_id); identifiers fill gaps\n3. **Batch query with IN clause** — one query for all name variants, not N separate queries\n4. **Prefer relationship over identifier** when both exist at same (file, line) — relationship has more context\n\n### Risk Assessment\n- **Low risk**: Database queries are read-only, additive to existing behavior\n- **Medium risk**: Deduplication logic needs to handle edge cases (same line, different columns)\n- **Testing**: Dogfood fixture DB must have identifiers populated (audit confirmed tiny fixture has 3, full workspace has ~1.2M)\n",
  "git": {
    "branch": "main",
    "commit": "060814f92a223b15b6c6259f91eff313dae3f15e",
    "dirty": true
  }
}